<h2>8.1. Flujos de Trabajo Importantes</h2>
<p>El proyecto OlympicAI Landing V3 implementa varios flujos de trabajo clave que forman la base de la experiencia del usuario:</p>

<h3>8.1.1. Flujo de Inicialización de la Aplicación</h3>
<p>Este es el flujo principal que se ejecuta cuando el usuario accede a la landing page:</p>
<pre>
1. Carga del componente App.vue
2. Montaje del componente Landing.vue
3. Inicialización del sistema de partículas (tsParticles)
4. Configuración del contador regresivo
5. Inicio del timer de actualización
6. Renderizado de la interfaz responsiva
</pre>

<h3>8.1.2. Flujo del Contador Regresivo</h3>
<p>El contador regresivo es una funcionalidad crítica que mantiene la expectativa del evento:</p>
<pre>
1. Definición de la fecha objetivo (2025-09-18T18:00:00)
2. Cálculo de la diferencia de tiempo en cada segundo
3. Actualización del estado reactivo (countdown)
4. Renderizado automático de los valores en la interfaz
5. Manejo del estado cuando el evento ha terminado
</pre>

<h3>8.1.3. Flujo de Efectos Visuales</h3>
<p>Los efectos visuales crean la experiencia inmersiva:</p>
<pre>
1. Configuración del sistema de partículas
2. Aplicación de efectos de fondo y texturas
3. Animaciones CSS y GSAP
4. Efectos de hover y transiciones
5. Adaptación responsiva de efectos
</pre>

<h2>8.2. Componentes Clave Involucrados</h2>

<h3>8.2.1. Componente Landing.vue</h3>
<p>Este es el componente principal que orquesta toda la lógica de negocio:</p>

<h4>Responsabilidades del Componente</h4>
<ul>
    <li><strong>Gestión del Estado:</strong> Manejo del estado reactivo del contador</li>
    <li><strong>Efectos Visuales:</strong> Configuración de partículas y animaciones</li>
    <li><strong>Responsividad:</strong> Adaptación del layout a diferentes dispositivos</li>
    <li><strong>Lifecycle Management:</strong> Inicialización y limpieza de recursos</li>
</ul>

<h4>Estructura del Componente</h4>
<pre><code>&lt;template&gt;
  &lt;!-- Estructura HTML responsiva --&gt;
&lt;/template&gt;

&lt;script setup&gt;
  // Lógica de negocio y efectos
&lt;/script&gt;

&lt;style scoped&gt;
  /* Estilos y animaciones */
&lt;/style&gt;</code></pre>

<h3>8.2.2. Sistema de Partículas (tsParticles)</h3>
<p>El sistema de partículas es responsable de crear el ambiente visual futurista:</p>
<ul>
    <li><strong>Configuración:</strong> Definición de partículas, enlaces y comportamiento</li>
    <li><strong>Interactividad:</strong> Respuesta al movimiento del mouse</li>
    <li><strong>Performance:</strong> Optimización para diferentes dispositivos</li>
    <li><strong>Personalización:</strong> Colores y efectos específicos del tema</li>
</ul>

<h3>8.2.3. Sistema de Contador Regresivo</h3>
<p>El contador regresivo es un sistema complejo que incluye:</p>
<ul>
    <li><strong>Cálculo de Tiempo:</strong> Conversión de milisegundos a días, horas, minutos, segundos</li>
    <li><strong>Estado Reactivo:</strong> Actualización automática de la interfaz</li>
    <li><strong>Manejo de Errores:</strong> Gestión cuando el evento ha terminado</li>
    <li><strong>Optimización:</strong> Uso de setInterval para actualizaciones eficientes</li>
</ul>

<h2>8.3. Explicación del Patrón de Componentes Vue.js</h2>

<h3>8.3.1. Composition API con &lt;script setup&gt;</h3>
<p>El proyecto utiliza la Composition API moderna de Vue 3, que proporciona:</p>

<h4>Ventajas del Patrón Utilizado</h4>
<ul>
    <li><strong>Mejor Tree Shaking:</strong> Código no utilizado se elimina automáticamente</li>
    <li><strong>Mejor Inferencia de Tipos:</strong> Soporte mejorado para TypeScript</li>
    <li><strong>Código Más Conciso:</strong> Menos boilerplate que Options API</li>
    <li><strong>Mejor Performance:</strong> Optimizaciones de tiempo de ejecución</li>
</ul>

<h4>Ejemplo de Implementación</h4>
<pre><code>&lt;script setup&gt;
import { ref, onMounted, onUnmounted } from 'vue'

// Estado reactivo
const countdown = ref({
  days: '00',
  hours: '00',
  minutes: '00',
  seconds: '00'
})

// Variables de configuración
const eventDateTime = '2025-09-18T18:00:00'
let timer = null

// Lógica de negocio
const updateCountdown = () => {
  const now = new Date()
  const targetDate = new Date(eventDateTime)
  const diff = targetDate.getTime() - now.getTime()
  
  if (diff > 0) {
    const days = Math.floor(diff / (1000 * 60 * 60 * 24))
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60))
    const seconds = Math.floor((diff % (1000 * 60)) / 1000)
    
    countdown.value = {
      days: String(days).padStart(2, '0'),
      hours: String(hours).padStart(2, '0'),
      minutes: String(minutes).padStart(2, '0'),
      seconds: String(seconds).padStart(2, '0')
    }
  } else {
    countdown.value = {
      days: '00',
      hours: '00',
      minutes: '00',
      seconds: '00'
    }
  }
}

// Lifecycle hooks
onMounted(() => {
  updateCountdown()
  timer = setInterval(updateCountdown, 1000)
})

onUnmounted(() => {
  if (timer) {
    clearInterval(timer)
  }
})
&lt;/script&gt;</code></pre>

<h3>8.3.2. Template (Vista)</h3>
<p>El template maneja la presentación y la interacción con el usuario:</p>

<h4>Estructura del Template</h4>
<pre><code>&lt;template&gt;
  &lt;div class="min-h-screen relative flex flex-col"&gt;
    &lt;!-- Fondo con efectos --&gt;
    &lt;div class="fixed inset-0 z-0 bg-black pointer-events-none"&gt;
      &lt;!-- Sistema de partículas --&gt;
      &lt;div id="light"&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;!-- Contenido principal --&gt;
    &lt;main class="relative z-10 px-6 flex-1 flex items-center justify-center"&gt;
      &lt;div class="grid-container"&gt;
        &lt;!-- Logo --&gt;
        &lt;div class="logo-container"&gt;
          &lt;img :src="newLogoImg" alt="Logo" class="logo-image" /&gt;
        &lt;/div&gt;
        
        &lt;!-- Título principal --&gt;
        &lt;div class="main-title"&gt;
          &lt;h1&gt;OLIMPIADAS UNIVERSITARIAS DE IA 2025&lt;/h1&gt;
        &lt;/div&gt;
        
        &lt;!-- Descripción --&gt;
        &lt;div class="description"&gt;
          &lt;p&gt;Compite con los mejores estudiantes...&lt;/p&gt;
        &lt;/div&gt;
        
        &lt;!-- Contador regresivo --&gt;
        &lt;div class="countdown-container"&gt;
          &lt;div class="countdown-grid"&gt;
            &lt;div class="countdown-card"&gt;
              &lt;div&gt;{{ countdown.days }}&lt;/div&gt;
              &lt;div&gt;Días&lt;/div&gt;
            &lt;/div&gt;
            &lt;!-- Más tarjetas de countdown --&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>

<h3>8.3.3. Estilos (CSS)</h3>
<p>Los estilos manejan la presentación visual y las animaciones:</p>

<h4>Características de los Estilos</h4>
<ul>
    <li><strong>Responsive Design:</strong> CSS Grid y Flexbox para layouts adaptativos</li>
    <li><strong>Animaciones CSS:</strong> Keyframes para efectos de hover y transiciones</li>
    <li><strong>Tailwind CSS:</strong> Clases utilitarias para diseño rápido</li>
    <li><strong>Custom CSS:</strong> Estilos específicos para efectos especiales</li>
</ul>

<h4>Ejemplo de Estilos</h4>
<pre><code>&lt;style scoped&gt;
/* Animaciones personalizadas */
@keyframes float {
  0%, 100% { transform: translateY(0px) rotate(0deg); }
  50% { transform: translateY(-10px) rotate(180deg); }
}

@keyframes pulse-glow {
  0%, 100% { opacity: 0.4; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.1); }
}

/* Layout responsivo */
.grid-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 24px 80px;
}

@media (max-width: 768px) {
  .grid-container {
    grid-template-columns: 1fr;
  }
}

/* Efectos de hover */
.countdown-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 8px 32px rgba(39, 196, 121, 0.7);
}
&lt;/style&gt;</code></pre>

<h2>8.4. Lógica de Negocio Específica</h2>

<h3>8.4.1. Cálculo del Contador Regresivo</h3>
<p>La lógica del contador regresivo es un proceso matemático complejo:</p>

<h4>Algoritmo de Cálculo</h4>
<pre><code>// Función de actualización del countdown
const updateCountdown = () => {
  const now = new Date()
  const targetDate = new Date(eventDateTime)
  const diff = targetDate.getTime() - now.getTime()
  
  if (diff > 0) {
    // Cálculo de días
    const days = Math.floor(diff / (1000 * 60 * 60 * 24))
    
    // Cálculo de horas (resto de días)
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))
    
    // Cálculo de minutos (resto de horas)
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60))
    
    // Cálculo de segundos (resto de minutos)
    const seconds = Math.floor((diff % (1000 * 60)) / 1000)
    
    // Formateo con ceros a la izquierda
    countdown.value = {
      days: String(days).padStart(2, '0'),
      hours: String(hours).padStart(2, '0'),
      minutes: String(minutes).padStart(2, '0'),
      seconds: String(seconds).padStart(2, '0')
    }
  } else {
    // Evento ha terminado
    countdown.value = {
      days: '00',
      hours: '00',
      minutes: '00',
      seconds: '00'
    }
  }
}</code></pre>

<h3>8.4.2. Configuración del Sistema de Partículas</h3>
<p>El sistema de partículas utiliza una configuración compleja para crear efectos visuales:</p>

<h4>Configuración de tsParticles</h4>
<pre><code>// Configuración del sistema de partículas
await tsParticles.load({
  id: "light",
  options: {
    preset: "lightdark",
    particles: {
      color: {
        value: ["#27c479", "#4ade80", "#1b7069"]
      },
      links: {
        color: "#27c479",
        opacity: 0.03,
        width: 2
      },
      size: {
        value: { min: 5, max: 5 }
      },
      opacity: {
        value: { min: 0.3, max: 0.55 }
      }
    }
  }
})</code></pre>

<h3>8.4.3. Gestión del Lifecycle</h3>
<p>La gestión del ciclo de vida es crítica para el rendimiento:</p>

<h4>Inicialización (onMounted)</h4>
<pre><code>onMounted(() => {
  // Inicializar contador
  updateCountdown()
  
  // Iniciar timer de actualización
  timer = setInterval(updateCountdown, 1000)
  
  // Configurar sistema de partículas
  setupParticles()
})</code></pre>

<h4>Limpieza (onUnmounted)</h4>
<pre><code>onUnmounted(() => {
  // Limpiar timer para evitar memory leaks
  if (timer) {
    clearInterval(timer)
  }
  
  // Limpiar sistema de partículas
  if (tsParticles) {
    tsParticles.destroy()
  }
})</code></pre>

<h2>8.5. Procesos de Negocio Clave</h2>

<h3>8.5.1. Proceso de Experiencia del Usuario</h3>
<p>El flujo de experiencia del usuario está diseñado para maximizar el engagement:</p>

<ol>
    <li><strong>Primera Impresión:</strong> Efectos visuales impactantes al cargar</li>
    <li><strong>Información Clara:</strong> Título y descripción del evento</li>
    <li><strong>Urgencia:</strong> Contador regresivo que genera expectativa</li>
    <li><strong>Interactividad:</strong> Efectos de hover y animaciones</li>
    <li><strong>Responsividad:</strong> Experiencia optimizada en todos los dispositivos</li>
</ol>

<h3>8.5.2. Proceso de Adaptación Responsiva</h3>
<p>El sistema de responsividad maneja diferentes tamaños de pantalla:</p>

<h4>Breakpoints Implementados</h4>
<ul>
    <li><strong>Desktop (&gt;1024px):</strong> Layout de dos columnas completo</li>
    <li><strong>Tablet (768px-1024px):</strong> Layout adaptado con espaciado reducido</li>
    <li><strong>Mobile (&lt;768px):</strong> Layout de una columna centrado</li>
    <li><strong>Small Mobile (&lt;640px):</strong> Contador horizontal compacto</li>
</ul>

<h3>8.5.3. Proceso de Optimización de Rendimiento</h3>
<p>Varias técnicas se implementan para optimizar el rendimiento:</p>

<h4>Técnicas de Optimización</h4>
<ul>
    <li><strong>Lazy Loading:</strong> Carga diferida de recursos pesados</li>
    <li><strong>Debouncing:</strong> Limitación de actualizaciones frecuentes</li>
    <li><strong>CSS Optimizations:</strong> Uso de transform y opacity para animaciones</li>
    <li><strong>Memory Management:</strong> Limpieza de timers y listeners</li>
</ul>

<h2>8.6. Integración de Librerías Externas</h2>

<h3>8.6.1. Integración con GSAP</h3>
<p>GSAP se utiliza para animaciones avanzadas:</p>
<ul>
    <li><strong>Timeline Animations:</strong> Secuencias de animación complejas</li>
    <li><strong>Performance:</strong> Animaciones optimizadas para GPU</li>
    <li><strong>Cross-browser:</strong> Compatibilidad con todos los navegadores</li>
</ul>

<h3>8.6.2. Integración con tsParticles</h3>
<p>tsParticles proporciona efectos de partículas interactivos:</p>
<ul>
    <li><strong>Configuración Dinámica:</strong> Partículas que responden al mouse</li>
    <li><strong>Performance:</strong> Optimización automática para dispositivos</li>
    <li><strong>Personalización:</strong> Colores y efectos específicos del tema</li>
</ul>

<h3>8.6.3. Integración con Tailwind CSS</h4>
<p>Tailwind CSS proporciona utilidades para diseño rápido:</p>
<ul>
    <li><strong>Utility Classes:</strong> Clases predefinidas para diseño rápido</li>
    <li><strong>Responsive Design:</strong> Breakpoints integrados</li>
    <li><strong>Customization:</strong> Configuración personalizada del tema</li>
</ul>

<h2>8.7. Manejo de Estados y Reactividad</h2>

<h3>8.7.1. Estado Reactivo Principal</h3>
<p>El estado principal de la aplicación se maneja con Vue 3 Reactivity:</p>

<h4>Estado del Contador</h4>
<pre><code>// Estado reactivo del contador
const countdown = ref({
  days: '00',
  hours: '00',
  minutes: '00',
  seconds: '00'
})

// El template se actualiza automáticamente cuando cambia countdown.value
// {{ countdown.days }} se actualiza en tiempo real</code></pre>

<h3>8.7.2. Computed Properties</h3>
<p>Las propiedades computadas se pueden usar para lógica derivada:</p>
<pre><code>// Ejemplo de computed property
const isEventActive = computed(() => {
  const now = new Date()
  const targetDate = new Date(eventDateTime)
  return targetDate.getTime() > now.getTime()
})

const timeUntilEvent = computed(() => {
  const now = new Date()
  const targetDate = new Date(eventDateTime)
  return targetDate.getTime() - now.getTime()
})</code></pre>

<h2>8.8. Escalabilidad y Mantenibilidad</h2>

<h3>8.8.1. Preparación para Escalabilidad</h3>
<p>La arquitectura está diseñada para facilitar futuras expansiones:</p>
<ul>
    <li><strong>Componentes Modulares:</strong> Fácil adición de nuevos componentes</li>
    <li><strong>Composables Reutilizables:</strong> Lógica de negocio reutilizable</li>
    <li><strong>Configuración Centralizada:</strong> Fácil modificación de parámetros</li>
    <li><strong>API Ready:</strong> Preparado para integración con backend</li>
</ul>

<h3>8.8.2. Estrategias de Mantenimiento</h3>
<p>El código está estructurado para facilitar el mantenimiento:</p>
<ul>
    <li><strong>Separación de Responsabilidades:</strong> Template, Script y Style separados</li>
    <li><strong>Código Documentado:</strong> Comentarios explicativos en secciones complejas</li>
    <li><strong>Nomenclatura Clara:</strong> Nombres descriptivos para variables y funciones</li>
    <li><strong>Configuración Externa:</strong> Fechas y parámetros fácilmente modificables</li>
</ul> 